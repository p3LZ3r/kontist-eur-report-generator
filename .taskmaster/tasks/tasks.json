{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize SPA Project with Vite, React, and Tailwind CSS",
        "description": "Set up the foundational client-side project structure for the EÜR Report Generator Single-Page Application (SPA).",
        "details": "Use Vite to scaffold a new React project. Integrate Tailwind CSS for styling as per the 'Logical Dependency Chain' foundation step. Establish the basic folder structure for components, logic (engines), and data models (`RawTransaction`, `NormalizedTransaction`, `EuerReport`).",
        "testStrategy": "Verify that the development server runs successfully and that a basic component with Tailwind CSS classes renders correctly in the browser.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Build Static UI Components for Upload and Report Display",
        "description": "Create the static, non-functional React components for the main application interface based on the specified user flow.",
        "details": "Implement a single-page layout as per the 'UI/UX Considerations'. Create a file input component with a clear call-to-action for CSV upload. Build a placeholder report display component with static labels matching the official EÜR form terminology.",
        "testStrategy": "Visual verification of components in the app or a tool like Storybook. Ensure the layout is clean, minimal, and follows the single-page design principle.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement CSV Parser and Data Normalization Logic",
        "description": "Develop the client-side logic to parse uploaded CSV files from Kontist and Holvi and transform them into a standardized internal format.",
        "details": "Use a client-side parsing library. Implement distinct adapters for Kontist and Holvi formats to handle potential future changes. The parser must identify the source bank and convert each row into the `NormalizedTransaction` data model.",
        "testStrategy": "Unit test the parsing and normalization logic with sample Kontist and Holvi CSV files. Assert that the output array of `NormalizedTransaction` objects is correct for both formats.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Develop SKR Categorization Engine",
        "description": "Create the core engine to automatically assign an official SKR accounting category to each transaction.",
        "details": "Build a function that takes a `NormalizedTransaction` and a ruleset. The engine will use keyword and pattern matching on the transaction description to map it to an SKR03/SKR04 category. The ruleset will be loaded from a JSON file as specified in the Appendix.",
        "testStrategy": "Write extensive unit tests. For a given transaction description and ruleset, assert that the correct SKR category is returned. Test edge cases and transactions that should remain uncategorized.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop EÜR Calculation Engine",
        "description": "Create the logic to calculate final EÜR financial figures from the set of categorized transactions.",
        "details": "Build a function that takes an array of categorized transactions. It will iterate through them, summing up income and expenses into buckets corresponding to the EÜR form fields. The output should match the `EuerReport` data model, calculating total income, expenses, and final profit/loss.",
        "testStrategy": "Unit test the calculation engine with various sets of categorized transactions. Verify that total income, total expenses, profit/loss, and category-specific totals are calculated correctly.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate Components for End-to-End Flow",
        "description": "Connect the UI, parser, and engines to create the complete, functional user workflow from file upload to final calculation and export.",
        "status": "done",
        "dependencies": [
          2,
          5
        ],
        "priority": "high",
        "details": "Wire the file upload component (Task 2) to trigger the CSV parser (Task 3). Pass the normalized transactions to the categorization engine (Task 4) and then to the calculation engine (Task 5). The final `EuerReport` object should be stored in the application's state, making it available for the report display (Task 7) and ELSTER export.",
        "testStrategy": "Manual end-to-end testing. Upload a test CSV and verify using browser dev tools that the application state is correctly updated with the final report data. Implement and test a loading indicator during processing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Connect File Upload UI to CSV Parser",
            "description": "Wire the file input component to trigger the CSV parsing logic upon file selection.",
            "status": "done",
            "dependencies": [],
            "details": "Implement an `onChange` handler for the file input from Task 2. Use the FileReader API to read the selected file's content and pass it to the CSV parser function from Task 3. Handle potential file reading errors.",
            "testStrategy": "Manually upload a file and use console logs or a debugger to confirm the parser function is called with the file content."
          },
          {
            "id": 2,
            "title": "Chain Parser Output to Categorization Engine",
            "description": "Pass the normalized transactions from the parser to the categorization engine.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Once the parser successfully returns an array of `NormalizedTransaction` objects, pass this array as input to the categorization engine (Task 4). This will enrich each transaction object with an EÜR category.",
            "testStrategy": "After parsing, inspect the data being passed to the categorization engine to ensure it's the correct array of normalized transactions."
          },
          {
            "id": 3,
            "title": "Feed Categorized Data into Calculation Engine",
            "description": "Use the output of the categorization engine to run the final EÜR calculations.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Take the array of categorized transactions and pass it to the EÜR calculation engine (Task 5). The engine will process this data and return the final `EuerReport` object.",
            "testStrategy": "Verify that the calculation engine receives the categorized transactions and that its output is a structured `EuerReport` object."
          },
          {
            "id": 4,
            "title": "Store Final Report in Application State",
            "description": "Update the global application state with the generated `EuerReport` and processing status.",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement state management logic (e.g., React Context). On successful calculation, update the state with the `EuerReport` object. Implement a loading state that is active from file selection until the calculation is complete. Handle and store any errors that occur during the process.",
            "testStrategy": "Use React DevTools to inspect the application state. Verify the loading state is set during processing and that the final state contains the correct `EuerReport` object or an error message."
          },
          {
            "id": 5,
            "title": "Implement ELSTER Data Export Function",
            "description": "Create a function to export the calculated EÜR report data into a downloadable format.",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "Add a button to the UI that becomes active after a report is generated. On click, this button should trigger a function that formats the `EuerReport` data into a simple, structured format (e.g., a key-value CSV or JSON file) and initiates a browser download.",
            "testStrategy": "Generate a report, click the export button, and verify that a file is downloaded. Inspect the file's contents to ensure it accurately reflects the data from the `EuerReport` object."
          }
        ]
      },
      {
        "id": 7,
        "title": "Populate Report Display with Calculated Data",
        "description": "Dynamically render the calculated EÜR report in the UI, making it ready for the user to transcribe to ELSTER.",
        "details": "Modify the report display component (Task 2) to consume the `EuerReport` data from the application state. Display the key calculated values with labels and line numbers that directly correspond to the official EÜR form, as specified in 'ELSTER-mapped Report Display'.",
        "testStrategy": "Visual and functional testing. Upload a test CSV and verify that the numbers displayed in the UI match the expected calculated totals. Cross-reference the UI labels with the official EÜR form.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Comprehensive Unit Testing for Core Logic",
        "description": "Fulfill the MVP requirement for unit tests covering the calculation and categorization logic.",
        "details": "Review and expand the unit tests for the categorization (Task 4) and calculation (Task 5) engines. Ensure high test coverage for these critical components to mitigate the risk of inaccurate financial reporting.",
        "testStrategy": "Run the full test suite and check coverage reports. Ensure tests cover common freelance income/expense types and edge cases.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Review & Document Categorization Engine Test Coverage",
            "description": "Analyze existing unit tests for the SKR Categorization Engine (Task 4), documenting current test cases, their coverage, and initial areas for expansion.",
            "dependencies": [],
            "details": "Utilize code coverage tools to assess current coverage. Document existing test cases for keyword/pattern matching, and uncategorized transactions as per Task 4's original test strategy.\n<info added on 2025-09-04T16:34:04.062Z>\nInitial review in 8.1 found a critical gap: no prior unit tests existed for the categorization engine. While a new suite (`src/test/categoryMappings.test.ts`) was created to validate static category definitions, the dynamic categorization logic remains untested.\n\nThis subtask will address this by adding tests for the core categorization algorithm, focusing on:\n- Keyword/pattern matching logic for assigning categories to transactions.\n- Fallback behavior for uncategorized transactions.\n- Correct category assignment using a variety of transaction descriptions and edge cases.\n- Multi-language keyword support.\n</info added on 2025-09-04T16:34:04.062Z>",
            "status": "done",
            "testStrategy": "N/A (This subtask focuses on review and documentation of existing tests)"
          },
          {
            "id": 2,
            "title": "Expand Categorization Engine Unit Tests",
            "description": "Develop new unit tests for the SKR Categorization Engine (Task 4) to cover common freelance income/expense types and specific edge cases, ensuring comprehensive coverage.",
            "dependencies": [
              "8.1"
            ],
            "details": "Focus on scenarios not adequately covered by existing tests, including ambiguous descriptions, multiple matching rules, and transactions that should remain uncategorized. Ensure tests align with the parent task's requirement for covering common freelance income/expense types and edge cases.",
            "status": "done",
            "testStrategy": "Write new unit tests using various transaction descriptions and rulesets, asserting correct SKR category assignment or non-assignment for identified gaps."
          },
          {
            "id": 3,
            "title": "Review & Document Calculation Engine Test Coverage",
            "description": "Analyze existing unit tests for the EÜR Calculation Engine (Task 5), documenting current test cases, their coverage, and initial areas for expansion.",
            "dependencies": [],
            "details": "Utilize code coverage tools to assess current coverage. Document existing test cases for various income/expense types, profit/loss calculation, and category-specific totals as per Task 5's original test strategy.",
            "status": "done",
            "testStrategy": "N/A (This subtask focuses on review and documentation of existing tests)"
          },
          {
            "id": 4,
            "title": "Expand Calculation Engine Unit Tests",
            "description": "Develop new unit tests for the EÜR Calculation Engine (Task 5) using diverse sets of categorized transactions to verify accurate financial figure calculation across various scenarios.",
            "dependencies": [
              "8.3"
            ],
            "details": "Create test data targeting the calculation of total income, total expenses, profit/loss, and category-specific totals under conditions like zero values, mixed types, and large transaction volumes. Ensure tests align with the parent task's requirement for covering common freelance income/expense types and edge cases.",
            "status": "done",
            "testStrategy": "Write new unit tests with varied categorized transaction inputs, asserting correct output for `EuerReport` fields."
          },
          {
            "id": 5,
            "title": "Achieve & Verify High Test Coverage for Core Logic",
            "description": "Run the full unit test suite for both Categorization (Task 4) and Calculation (Task 5) engines, analyze coverage reports, and ensure high test coverage (e.g., >90% line coverage) for their core logic.",
            "dependencies": [
              "8.2",
              "8.4"
            ],
            "details": "Use the configured test runner and coverage reporting tools. Address any remaining low-coverage areas by adding targeted tests until the high test coverage requirement is met for both critical components.",
            "status": "done",
            "testStrategy": "Run the full test suite and check coverage reports. Ensure the target coverage percentage is met for both the categorization and calculation engines."
          }
        ]
      },
      {
        "id": 9,
        "title": "Refine UI/UX and Handle Error States",
        "description": "Polish the user interface and implement robust handling for potential user errors and edge cases.",
        "details": "Implement user-friendly error messages for invalid file types (non-CSV), corrupted files, or parsing failures. Add a small info section explaining the client-side privacy model. Ensure the entire experience is intuitive for the non-accountant user persona.",
        "testStrategy": "Manual testing of error paths: upload a .txt file, a corrupted CSV, or a CSV from an unsupported bank. Ensure clear, helpful feedback is provided to the user.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Configure Static Site Deployment",
        "description": "Set up automated deployment to a static web hosting provider to make the MVP publicly accessible.",
        "details": "Configure a CI/CD pipeline (e.g., using GitHub Actions) to automatically build and deploy the application to a provider like Vercel, Netlify, or GitHub Pages upon pushes to the main branch.",
        "testStrategy": "Trigger a deployment by pushing a commit. Verify that the deployed site is live and fully functional by performing a complete user flow on the production URL.",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "in-progress",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-04T07:57:30.681Z",
      "updated": "2025-09-04T17:15:10.301Z",
      "description": "Tasks for master context"
    }
  }
}