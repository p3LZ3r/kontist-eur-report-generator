{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize SPA Project with Vite, React, and Tailwind CSS",
        "description": "Set up the foundational client-side project structure for the EÜR Report Generator Single-Page Application (SPA).",
        "details": "Use Vite to scaffold a new React project. Integrate Tailwind CSS for styling as per the 'Logical Dependency Chain' foundation step. Establish the basic folder structure for components, logic (engines), and data models (`RawTransaction`, `NormalizedTransaction`, `EuerReport`).",
        "testStrategy": "Verify that the development server runs successfully and that a basic component with Tailwind CSS classes renders correctly in the browser.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Build Static UI Components for Upload and Report Display",
        "description": "Create the static, non-functional React components for the main application interface based on the specified user flow.",
        "details": "Implement a single-page layout as per the 'UI/UX Considerations'. Create a file input component with a clear call-to-action for CSV upload. Build a placeholder report display component with static labels matching the official EÜR form terminology.",
        "testStrategy": "Visual verification of components in the app or a tool like Storybook. Ensure the layout is clean, minimal, and follows the single-page design principle.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement CSV Parser and Data Normalization Logic",
        "description": "Develop the client-side logic to parse uploaded CSV files from Kontist and Holvi and transform them into a standardized internal format.",
        "details": "Use a client-side parsing library. Implement distinct adapters for Kontist and Holvi formats to handle potential future changes. The parser must identify the source bank and convert each row into the `NormalizedTransaction` data model.",
        "testStrategy": "Unit test the parsing and normalization logic with sample Kontist and Holvi CSV files. Assert that the output array of `NormalizedTransaction` objects is correct for both formats.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Develop SKR Categorization Engine",
        "description": "Create the core engine to automatically assign an official SKR accounting category to each transaction.",
        "details": "Build a function that takes a `NormalizedTransaction` and a ruleset. The engine will use keyword and pattern matching on the transaction description to map it to an SKR03/SKR04 category. The ruleset will be loaded from a JSON file as specified in the Appendix.",
        "testStrategy": "Write extensive unit tests. For a given transaction description and ruleset, assert that the correct SKR category is returned. Test edge cases and transactions that should remain uncategorized.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop EÜR Calculation Engine",
        "description": "Create the logic to calculate final EÜR financial figures from the set of categorized transactions.",
        "details": "Build a function that takes an array of categorized transactions. It will iterate through them, summing up income and expenses into buckets corresponding to the EÜR form fields. The output should match the `EuerReport` data model, calculating total income, expenses, and final profit/loss.",
        "testStrategy": "Unit test the calculation engine with various sets of categorized transactions. Verify that total income, total expenses, profit/loss, and category-specific totals are calculated correctly.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate Components for End-to-End Flow",
        "description": "Connect the UI, parser, and engines to create the complete, functional user workflow from file upload to final calculation and export.",
        "status": "done",
        "dependencies": [
          2,
          5
        ],
        "priority": "high",
        "details": "Wire the file upload component (Task 2) to trigger the CSV parser (Task 3). Pass the normalized transactions to the categorization engine (Task 4) and then to the calculation engine (Task 5). The final `EuerReport` object should be stored in the application's state, making it available for the report display (Task 7) and ELSTER export.",
        "testStrategy": "Manual end-to-end testing. Upload a test CSV and verify using browser dev tools that the application state is correctly updated with the final report data. Implement and test a loading indicator during processing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Connect File Upload UI to CSV Parser",
            "description": "Wire the file input component to trigger the CSV parsing logic upon file selection.",
            "status": "done",
            "dependencies": [],
            "details": "Implement an `onChange` handler for the file input from Task 2. Use the FileReader API to read the selected file's content and pass it to the CSV parser function from Task 3. Handle potential file reading errors.",
            "testStrategy": "Manually upload a file and use console logs or a debugger to confirm the parser function is called with the file content."
          },
          {
            "id": 2,
            "title": "Chain Parser Output to Categorization Engine",
            "description": "Pass the normalized transactions from the parser to the categorization engine.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Once the parser successfully returns an array of `NormalizedTransaction` objects, pass this array as input to the categorization engine (Task 4). This will enrich each transaction object with an EÜR category.",
            "testStrategy": "After parsing, inspect the data being passed to the categorization engine to ensure it's the correct array of normalized transactions."
          },
          {
            "id": 3,
            "title": "Feed Categorized Data into Calculation Engine",
            "description": "Use the output of the categorization engine to run the final EÜR calculations.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Take the array of categorized transactions and pass it to the EÜR calculation engine (Task 5). The engine will process this data and return the final `EuerReport` object.",
            "testStrategy": "Verify that the calculation engine receives the categorized transactions and that its output is a structured `EuerReport` object."
          },
          {
            "id": 4,
            "title": "Store Final Report in Application State",
            "description": "Update the global application state with the generated `EuerReport` and processing status.",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement state management logic (e.g., React Context). On successful calculation, update the state with the `EuerReport` object. Implement a loading state that is active from file selection until the calculation is complete. Handle and store any errors that occur during the process.",
            "testStrategy": "Use React DevTools to inspect the application state. Verify the loading state is set during processing and that the final state contains the correct `EuerReport` object or an error message."
          },
          {
            "id": 5,
            "title": "Implement ELSTER Data Export Function",
            "description": "Create a function to export the calculated EÜR report data into a downloadable format.",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "Add a button to the UI that becomes active after a report is generated. On click, this button should trigger a function that formats the `EuerReport` data into a simple, structured format (e.g., a key-value CSV or JSON file) and initiates a browser download.",
            "testStrategy": "Generate a report, click the export button, and verify that a file is downloaded. Inspect the file's contents to ensure it accurately reflects the data from the `EuerReport` object."
          }
        ]
      },
      {
        "id": 7,
        "title": "Populate Report Display with Calculated Data",
        "description": "Dynamically render the calculated EÜR report in the UI, making it ready for the user to transcribe to ELSTER.",
        "details": "Modify the report display component (Task 2) to consume the `EuerReport` data from the application state. Display the key calculated values with labels and line numbers that directly correspond to the official EÜR form, as specified in 'ELSTER-mapped Report Display'.",
        "testStrategy": "Visual and functional testing. Upload a test CSV and verify that the numbers displayed in the UI match the expected calculated totals. Cross-reference the UI labels with the official EÜR form.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Comprehensive Unit Testing for Core Logic",
        "description": "Fulfill the MVP requirement for unit tests covering the calculation and categorization logic.",
        "details": "Review and expand the unit tests for the categorization (Task 4) and calculation (Task 5) engines. Ensure high test coverage for these critical components to mitigate the risk of inaccurate financial reporting.",
        "testStrategy": "Run the full test suite and check coverage reports. Ensure tests cover common freelance income/expense types and edge cases.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Review & Document Categorization Engine Test Coverage",
            "description": "Analyze existing unit tests for the SKR Categorization Engine (Task 4), documenting current test cases, their coverage, and initial areas for expansion.",
            "dependencies": [],
            "details": "Utilize code coverage tools to assess current coverage. Document existing test cases for keyword/pattern matching, and uncategorized transactions as per Task 4's original test strategy.\n<info added on 2025-09-04T16:34:04.062Z>\nInitial review in 8.1 found a critical gap: no prior unit tests existed for the categorization engine. While a new suite (`src/test/categoryMappings.test.ts`) was created to validate static category definitions, the dynamic categorization logic remains untested.\n\nThis subtask will address this by adding tests for the core categorization algorithm, focusing on:\n- Keyword/pattern matching logic for assigning categories to transactions.\n- Fallback behavior for uncategorized transactions.\n- Correct category assignment using a variety of transaction descriptions and edge cases.\n- Multi-language keyword support.\n</info added on 2025-09-04T16:34:04.062Z>",
            "status": "done",
            "testStrategy": "N/A (This subtask focuses on review and documentation of existing tests)"
          },
          {
            "id": 2,
            "title": "Expand Categorization Engine Unit Tests",
            "description": "Develop new unit tests for the SKR Categorization Engine (Task 4) to cover common freelance income/expense types and specific edge cases, ensuring comprehensive coverage.",
            "dependencies": [
              "8.1"
            ],
            "details": "Focus on scenarios not adequately covered by existing tests, including ambiguous descriptions, multiple matching rules, and transactions that should remain uncategorized. Ensure tests align with the parent task's requirement for covering common freelance income/expense types and edge cases.",
            "status": "done",
            "testStrategy": "Write new unit tests using various transaction descriptions and rulesets, asserting correct SKR category assignment or non-assignment for identified gaps."
          },
          {
            "id": 3,
            "title": "Review & Document Calculation Engine Test Coverage",
            "description": "Analyze existing unit tests for the EÜR Calculation Engine (Task 5), documenting current test cases, their coverage, and initial areas for expansion.",
            "dependencies": [],
            "details": "Utilize code coverage tools to assess current coverage. Document existing test cases for various income/expense types, profit/loss calculation, and category-specific totals as per Task 5's original test strategy.",
            "status": "done",
            "testStrategy": "N/A (This subtask focuses on review and documentation of existing tests)"
          },
          {
            "id": 4,
            "title": "Expand Calculation Engine Unit Tests",
            "description": "Develop new unit tests for the EÜR Calculation Engine (Task 5) using diverse sets of categorized transactions to verify accurate financial figure calculation across various scenarios.",
            "dependencies": [
              "8.3"
            ],
            "details": "Create test data targeting the calculation of total income, total expenses, profit/loss, and category-specific totals under conditions like zero values, mixed types, and large transaction volumes. Ensure tests align with the parent task's requirement for covering common freelance income/expense types and edge cases.",
            "status": "done",
            "testStrategy": "Write new unit tests with varied categorized transaction inputs, asserting correct output for `EuerReport` fields."
          },
          {
            "id": 5,
            "title": "Achieve & Verify High Test Coverage for Core Logic",
            "description": "Run the full unit test suite for both Categorization (Task 4) and Calculation (Task 5) engines, analyze coverage reports, and ensure high test coverage (e.g., >90% line coverage) for their core logic.",
            "dependencies": [
              "8.2",
              "8.4"
            ],
            "details": "Use the configured test runner and coverage reporting tools. Address any remaining low-coverage areas by adding targeted tests until the high test coverage requirement is met for both critical components.",
            "status": "done",
            "testStrategy": "Run the full test suite and check coverage reports. Ensure the target coverage percentage is met for both the categorization and calculation engines."
          }
        ]
      },
      {
        "id": 9,
        "title": "Refine UI/UX and Handle Error States",
        "description": "Polish the user interface and implement robust handling for potential user errors and edge cases.",
        "details": "Implement user-friendly error messages for invalid file types (non-CSV), corrupted files, or parsing failures. Add a small info section explaining the client-side privacy model. Ensure the entire experience is intuitive for the non-accountant user persona.",
        "testStrategy": "Manual testing of error paths: upload a .txt file, a corrupted CSV, or a CSV from an unsupported bank. Ensure clear, helpful feedback is provided to the user.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Configure Static Site Deployment",
        "description": "Set up automated deployment to a static web hosting provider to make the MVP publicly accessible.",
        "details": "Configure a CI/CD pipeline (e.g., using GitHub Actions) to automatically build and deploy the application to a provider like Vercel, Netlify, or GitHub Pages upon pushes to the main branch.",
        "testStrategy": "Trigger a deployment by pushing a commit. Verify that the deployed site is live and fully functional by performing a complete user flow on the production URL.",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Setup SPA Project and Basic UI Shell",
        "description": "Initialize a client-side Single-Page Application (SPA) and create the main layout with placeholders for the file upload and report display areas.",
        "details": "Use Vite and Tailwind CSS as specified in the PRD. Create a single-page layout with a clear call-to-action for file upload and an empty placeholder section for the final report display. This task corresponds to the 'Foundation' and 'Static UI' steps in the logical dependency chain.",
        "testStrategy": "Run the development server and verify the basic layout renders correctly in the browser without errors. The file input and a placeholder for the report should be visible.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Define Core Data Models and Static Data",
        "description": "Create the TypeScript/JavaScript definitions for `RawTransaction`, `NormalizedTransaction`, and `EuerReport`, and set up the static SKR mapping files.",
        "details": "Define the data structures as specified in the 'Data Models' section of the PRD. Create `src/data/skr03.json` and `src/data/skr04.json` with initial mapping rules for common freelance income/expense categories.",
        "testStrategy": "Code review to ensure models match the PRD specifications. JSON files should be linted and validated to ensure they are parseable.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement CSV Parsing for Kontist & Holvi",
        "description": "Develop the logic to parse uploaded `.csv` files from Kontist and Holvi, transforming the data into the standardized `NormalizedTransaction` format.",
        "details": "Use a client-side CSV parsing library (e.g., PapaParse). Implement an adapter layer that detects the source bank (Kontist/Holvi) based on header columns and maps its specific format to the `NormalizedTransaction` model. Handle potential parsing errors gracefully.",
        "testStrategy": "Unit test the parsing logic with sample CSV files for both banks. Verify that the output is an array of valid `NormalizedTransaction` objects and that edge cases (empty files, malformed rows) are handled.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Build the SKR Categorization Engine",
        "description": "Create the core engine that assigns an SKR category to each `NormalizedTransaction` based on predefined rules.",
        "details": "The engine will iterate through an array of `NormalizedTransaction`s. It will use a ruleset based on keywords and patterns in the transaction description to match against the SKR mapping data loaded from the JSON files. Uncategorized items should be handled gracefully as per the PRD's risk mitigation.",
        "testStrategy": "Write unit tests that pass in various `NormalizedTransaction` objects and assert that the correct SKR category is assigned. Test with common freelance expenses like 'Software', 'Travel', and 'Office Supplies'.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Build the EÜR Calculation Engine",
        "description": "Create the logic to process the list of categorized transactions and compute the final EÜR report totals.",
        "details": "The engine will take an array of categorized `NormalizedTransaction`s as input. It will sum up all income and expense lines, grouping them by their assigned SKR category, to produce the final `EuerReport` object containing total income, total expenses, and profit/loss.",
        "testStrategy": "Unit test the calculation engine with a predefined set of categorized transactions. Verify that total income, total expenses, and profit/loss are calculated correctly. Test with zero transactions and only income/expense transactions.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Create the ELSTER-mapped Report Display",
        "description": "Build the UI component that takes the final `EuerReport` object and displays the results in a clean, read-only format matching the ELSTER form.",
        "details": "The component will render the key calculated values (e.g., 'Betriebseinnahmen', 'Wareneinkauf', 'Gewinn/Verlust') with labels and line numbers corresponding to the official EÜR form. This component will replace the placeholder from task 11.",
        "testStrategy": "Manually test by feeding a mock `EuerReport` object to the component and verifying the display is accurate, clean, and user-friendly. Check that all relevant fields from the report object are displayed.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Integrate All MVP Components for End-to-End Flow",
        "description": "Connect the file upload, parsing, categorization, calculation, and display components to create the complete, functional user workflow for the MVP.",
        "details": "Wire the file input to trigger the CSV parser. Pass the normalized data to the categorization and calculation engines. Feed the final `EuerReport` to the display component. Implement a loading indicator that is shown during processing.",
        "testStrategy": "Perform end-to-end manual testing: upload a Kontist CSV, verify the loading state, and check that the final report is displayed correctly. Repeat the process for a Holvi CSV.",
        "priority": "high",
        "dependencies": [
          13,
          15,
          16
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Project Repository and Basic Structure",
            "description": "Set up the version control repository, define initial project directories (e.g., `src`, `tests`, `docs`), and configure basic build tools and dependency management.",
            "dependencies": [],
            "details": "Use Git for version control. Create a `.gitignore` file. Configure `package.json` (for Node.js), `pyproject.toml` (for Python), or `pom.xml` (for Java) for dependency management. Establish a clear folder structure for frontend, backend, and shared components.",
            "status": "done",
            "testStrategy": "Verify repository creation and that basic build/install commands (e.g., `npm install`, `pip install -e .`) run without errors. Confirm `.gitignore` is effective."
          },
          {
            "id": 2,
            "title": "Design Database Schema and Configure ORM",
            "description": "Define the necessary database tables, relationships, and data types for the application's core entities. Integrate and configure an Object-Relational Mapper (ORM) to interact with the database.",
            "dependencies": [],
            "details": "Choose a suitable database (e.g., PostgreSQL, MySQL). Design tables for users, items, orders, etc., including primary keys, foreign keys, and appropriate data types. Use an ORM like SQLAlchemy, Sequelize, or Hibernate. Define ORM models corresponding to the database schema.",
            "status": "done",
            "testStrategy": "Write and apply initial database migration scripts to a local development database. Verify that ORM models can connect to the database and perform basic CRUD (Create, Read, Update, Delete) operations on dummy data."
          },
          {
            "id": 3,
            "title": "Develop Core Backend API Endpoints",
            "description": "Implement the essential RESTful API endpoints for data manipulation (CRUD operations) based on the defined database schema and ORM models.",
            "dependencies": [],
            "details": "Use a chosen backend framework (e.g., Flask, Express, Spring Boot). Implement endpoints for creating, reading, updating, and deleting primary resources (e.g., `/api/items`, `/api/users`). Ensure proper request validation, error handling, and serialization/deserialization of data.",
            "status": "done",
            "testStrategy": "Use an API client (e.g., Postman, Insomnia) or write unit/integration tests to verify each endpoint's functionality, HTTP status codes, and response payloads for various scenarios (success, invalid input, resource not found)."
          },
          {
            "id": 4,
            "title": "Implement Key Frontend UI Components",
            "description": "Create the main user interface components required for displaying and interacting with the data exposed by the backend API.",
            "dependencies": [],
            "details": "Choose a frontend framework (e.g., React, Angular, Vue.js). Develop reusable components such as data display tables/lists, forms for data input, navigation elements, and basic layout components. Focus on static rendering and component structure initially.",
            "status": "done",
            "testStrategy": "Visually inspect components in a browser to ensure correct rendering and responsiveness. Use component-level testing frameworks (e.g., Jest, React Testing Library) to verify components render correctly with different props and respond to basic simulated user interactions."
          },
          {
            "id": 5,
            "title": "Integrate Frontend with Backend API and Implement Data Flow",
            "description": "Connect the frontend UI components to the backend API endpoints to fetch, display, and submit data. Implement application-wide state management for data flow.",
            "dependencies": [],
            "details": "Use `fetch` API or a library like Axios for HTTP requests from the frontend. Implement data fetching on component mount, form submission handling, and real-time updates. Manage application state using a suitable pattern (e.g., Context API, Redux, Vuex, Zustand) to ensure consistent data across components.",
            "status": "done",
            "testStrategy": "Perform end-to-end testing by interacting with the UI and verifying that data is correctly fetched from and submitted to the backend. Use browser developer tools to monitor network requests and responses. Test various user flows involving data interaction."
          },
          {
            "id": 6,
            "title": "Implement User Authentication and Authorization",
            "description": "Add user authentication (e.g., login, registration, logout) and authorization (e.g., role-based access control) to secure the application's resources and features.",
            "dependencies": [],
            "details": "Implement user registration and login endpoints on the backend, using secure password hashing (e.g., bcrypt) and token-based (e.g., JWT) or session-based authentication. Protect API routes based on user roles/permissions. Implement login/logout UI flows, protected routes, and display user-specific content on the frontend.",
            "status": "done",
            "testStrategy": "Test login/logout functionality with valid and invalid credentials. Verify that protected API routes are inaccessible without proper authentication/authorization. Test different user roles to ensure correct access levels to features and data. Check for secure storage of tokens/sessions."
          }
        ]
      },
      {
        "id": 18,
        "title": "Integrate Polar.sh Payment Modal",
        "description": "Implement the payment modal that appears when a user clicks on an ELSTER export button or information icon.",
        "details": "Use the Polar.sh SDK to trigger and display the checkout modal. The modal should offer the option to make a voluntary payment or to skip and continue for free, as described in the user flow.",
        "testStrategy": "Manually trigger the modal from the UI. Verify the Polar.sh checkout loads correctly within the modal. Test the 'skip' functionality to ensure the user can proceed without paying.",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Product Database Schema",
            "description": "Define the database schema for products, categories, and related entities. Set up the database and initial tables.",
            "dependencies": [],
            "details": "Use PostgreSQL. Tables: `products` (id, name, description, price, stock, category_id), `categories` (id, name). Ensure proper indexing and foreign key constraints. Create migration scripts.\n<info added on 2025-09-10T07:33:10.471Z>\nWith the `PaymentModal.tsx` component now successfully integrating the Polar.sh SDK on the client side, this backend subtask is unblocked. The goal is to create an API endpoint that will serve the product/donation options from the database to the frontend.\n\n**Implementation Plan:**\n\n1.  **Create API Endpoint:** Implement a new `GET /api/products` endpoint. Following the existing backend structure, this will likely involve adding a new route in the `server/routes/` directory and a corresponding controller function.\n2.  **Database Query:** The controller for this endpoint should query the PostgreSQL `products` table (defined in subtask 18.1) to fetch all available products.\n3.  **Data Structure:** The endpoint should return a JSON array of product objects. Each object should include the necessary fields for the frontend, such as `id`, `name`, `description`, and `price`.\n4.  **Frontend Integration (Next Step):** Once this endpoint is live, the `PaymentModal.tsx` component will be refactored to fetch data from `/api/products` instead of using client-side dynamic values. This will decouple the product offerings from the frontend code.\n</info added on 2025-09-10T07:33:10.471Z>",
            "status": "done",
            "testStrategy": "Verify table creation, column types, constraints, and ability to insert/retrieve basic data using SQL queries directly against the database."
          },
          {
            "id": 2,
            "title": "Implement Product Listing API Endpoint",
            "description": "Create an API endpoint to retrieve a list of all products, with optional filtering and pagination.",
            "dependencies": [],
            "details": "Endpoint: `/api/products`. Support query parameters for `category_id`, `min_price`, `max_price`, `page`, `limit`. Use a RESTful approach, returning JSON.",
            "status": "done",
            "testStrategy": "Unit tests for data retrieval logic. Integration tests for the API endpoint using HTTP requests, checking various filter combinations, pagination, and empty results."
          },
          {
            "id": 3,
            "title": "Implement Single Product Details API Endpoint",
            "description": "Create an API endpoint to retrieve details for a specific product by its ID.",
            "dependencies": [],
            "details": "Endpoint: `/api/products/{id}`. Handle cases where the product ID does not exist (return 404 Not Found). Include category name in the response.",
            "status": "done",
            "testStrategy": "Unit tests for fetching by ID. Integration tests for the API endpoint, checking valid IDs, non-existent IDs, and ensuring correct data structure and status codes."
          },
          {
            "id": 4,
            "title": "Implement Product Creation API Endpoint",
            "description": "Create an API endpoint to allow authenticated users to add new products to the catalog.",
            "dependencies": [],
            "details": "Endpoint: `/api/products` (POST request). Request body should include `name`, `description`, `price`, `stock`, `category_id`. Implement input validation (e.g., price > 0, stock >= 0, category_id exists). Return 201 Created with the new product's details.",
            "status": "done",
            "testStrategy": "Unit tests for validation logic. Integration tests for the API endpoint, sending valid and invalid product data, verifying successful creation, and checking error responses for invalid inputs."
          }
        ]
      },
      {
        "id": 19,
        "title": "Manage Payment Flow and Add Secondary CTA",
        "description": "Implement logic to handle payment success/failure and add a subtle call-to-action for later contributions in the export view.",
        "details": "Use callbacks or promises from the Polar.sh SDK to detect payment completion. Display a simple confirmation message on success. Add a non-intrusive 'Support this tool' button in the final report view that re-opens the payment modal.",
        "testStrategy": "Use Polar.sh test mode to simulate a successful payment and verify the confirmation UI appears. Verify the secondary CTA is present and correctly triggers the payment modal again.",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Database Schema",
            "description": "Define the database schema for core entities (e.g., users, products, orders) and set up the initial database environment.",
            "dependencies": [],
            "details": "Create SQL DDL scripts for tables like `users` (id, name, email, password_hash), `products` (id, name, description, price, stock), and `orders` (id, user_id, order_date, total_amount). Use PostgreSQL for the database. Ensure proper indexing for foreign keys and frequently queried columns.",
            "status": "done",
            "testStrategy": "Verify table creation and schema integrity using a database client. Insert sample data to confirm data types and constraints are enforced correctly."
          },
          {
            "id": 2,
            "title": "Develop User Authentication and Authorization Module",
            "description": "Implement user registration, login, and token-based authentication (e.g., JWT). Include basic role-based authorization.",
            "dependencies": [],
            "details": "Create API endpoints for `/register` (POST), `/login` (POST), and `/profile` (GET, protected). Use bcrypt for password hashing. Implement JWT generation on login and validation for protected routes. Define roles (e.g., 'user', 'admin') and enforce access control on specific endpoints.",
            "status": "done",
            "testStrategy": "Test user registration with valid/invalid data. Verify successful login and JWT generation. Test access to protected routes with valid/invalid/missing tokens. Confirm authorization rules are applied correctly for different user roles."
          },
          {
            "id": 3,
            "title": "Implement Product Catalog Management API",
            "description": "Develop CRUD (Create, Read, Update, Delete) API endpoints for managing product information.",
            "dependencies": [],
            "details": "Create RESTful endpoints: `/products` (GET all, POST new), `/products/{id}` (GET by ID, PUT/PATCH update, DELETE). Implement input validation for product data (name, price, stock). Ensure only authenticated and authorized users (e.g., 'admin' role) can create, update, or delete products.",
            "status": "done",
            "testStrategy": "Use Postman or cURL to test all CRUD operations. Verify correct HTTP status codes (200, 201, 204, 400, 401, 403, 404). Test edge cases like invalid product IDs, missing required fields, and unauthorized access attempts."
          },
          {
            "id": 4,
            "title": "Set Up API Documentation and Deployment Configuration",
            "description": "Generate comprehensive API documentation and configure basic deployment settings for the application.",
            "dependencies": [],
            "details": "Use OpenAPI/Swagger to document all implemented API endpoints, including request/response schemas, authentication requirements, and error codes. Create a `Dockerfile` for containerizing the application and a basic `docker-compose.yml` for local development and testing environment setup.",
            "status": "done",
            "testStrategy": "Verify that the generated API documentation is accurate, complete, and accessible. Build the Docker image and run the application in a container to ensure it starts correctly and all endpoints are reachable from within the containerized environment."
          }
        ]
      },
      {
        "id": 20,
        "title": "Deploy MVP to Static Hosting",
        "description": "Configure and deploy the completed client-side application to a static web host like Vercel, Netlify, or GitHub Pages.",
        "details": "Set up a build pipeline for the SPA. Configure the chosen hosting provider to serve the static files from the `dist` directory. Ensure environment variables for Polar.sh (if any) are set up correctly.",
        "testStrategy": "Access the live URL and perform a final smoke test of the entire user flow, including file upload and the payment modal, to ensure it works correctly in a production environment.",
        "priority": "low",
        "dependencies": [
          17,
          19
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Research and Implement Compliant Payment Integration",
        "description": "Replace the current Polar.sh integration with a payment solution that complies with German regulations, avoiding the 'voluntary support' classification, and using appropriate terminology.",
        "details": "This task involves a multi-phase approach to replace the existing Polar.sh payment integration with a legally compliant alternative for the German market.\n\n**Phase 1: Research & Legal Clarification**\n*   Consult with legal counsel (if available) or thoroughly research German tax and commercial law (e.g., § 3 Abs. 9 UStG for services, § 10 Abs. 1 UStG for taxable base) regarding the distinction between 'voluntary support' (Spende) and 'payment for service' (Leistungsentgelt) for digital tools. Identify key characteristics that differentiate a donation from a service fee in the German context.\n*   Research alternative payment providers (e.g., Stripe, Paddle, PayPal Business, Mollie) suitable for the German market. Evaluate providers based on ease of integration, transaction fees, compliance features (e.g., VAT handling, Impressum requirements), and user experience.\n*   Define a clear payment model (e.g., fixed price for ELSTER export access, tiered pricing, or a 'pay-what-you-want' model explicitly framed as a purchase for the service).\n\n**Phase 2: Design & Terminology**\n*   Based on legal research, update all user-facing text related to payment (buttons, modal titles, descriptions, success messages) to use compliant terminology. Examples: 'ELSTER-Export freischalten' (Unlock ELSTER Export), 'Zugang erwerben' (Acquire Access), 'Preis wählen' (Choose Price) instead of 'Spenden' or 'Freiwillige Unterstützung'.\n*   Design the new payment modal/flow (likely modifying `src/components/PaymentModal.jsx` or similar) to clearly present the service being paid for, ensuring the UI communicates that a service is being provided in exchange for payment.\n\n**Phase 3: Implementation**\n*   **Remove Polar.sh:** Uninstall `@polar-sh/sdk` from `package.json`. Remove all related imports and calls from `src/components/PaymentModal.jsx`, `src/hooks/usePayment.js`, and any other files identified during codebase analysis that interact with Polar.sh.\n*   **Integrate New Provider:** Install the SDK/library for the chosen payment provider.\n*   **Refactor Payment Logic:**\n    *   Modify `src/components/PaymentModal.jsx` to integrate the new payment provider's checkout/modal functionality.\n    *   Update `src/hooks/usePayment.js` (or create a new equivalent) to encapsulate the new provider's API calls for initiating payments, handling success/failure callbacks, and managing payment state.\n    *   Ensure the payment initiation (e.g., from the ELSTER export button in `src/components/ReportDisplay.jsx`) correctly triggers the new, compliant payment flow.\n*   **Handle Payment Outcomes:** Implement robust logic to handle payment success, failure, and cancellation. This might involve listening to client-side callbacks or, if applicable, integrating with server-side webhooks for validation. Update the UI to reflect these states (e.g., confirmation message on success, clear error message on failure).\n*   **Secondary CTA:** Adjust the 'Support this tool' button (from Task 19, likely in `src/components/ReportDisplay.jsx`) to reflect the new terminology and trigger the new, compliant payment flow.\n\n**Phase 4: Legal & UI Review**\n*   Conduct a thorough internal review of the new payment flow, UI, and all associated texts to ensure alignment with the legal research and compliant terminology.",
        "testStrategy": "To verify the correct implementation and functionality:\n*   **Unit Tests:** If the chosen payment provider offers a test mode or mock API, write unit tests for the payment initiation and callback handling logic within `src/hooks/usePayment.js`.\n*   **Integration Tests (Sandbox/Test Mode):**\n    *   Use the chosen payment provider's sandbox/test environment to simulate successful payments, failed payments (e.g., invalid card, insufficient funds), and user cancellations.\n    *   Verify that the payment modal appears with the correct, compliant terminology and clearly presents the service being paid for.\n    *   Confirm that successful payments lead to the expected outcome (e.g., ELSTER export enabled, confirmation message displayed).\n    *   Verify that failed payments or cancellations are handled gracefully with appropriate user feedback.\n    *   Test the secondary CTA (e.g., in `src/components/ReportDisplay.jsx`) to ensure it correctly re-initiates the new, compliant payment flow.\n*   **Legal Review:** Have the implemented solution and all user-facing texts reviewed by a legal expert specializing in German commercial law to ensure full compliance with regulations.",
        "status": "pending",
        "dependencies": [
          18,
          19,
          2,
          9,
          17
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Remove ELSTER Export File Functionality",
        "description": "Remove the CSV and JSON file export features and associated UI elements, as they do not provide a valid import format for the ELSTER software.",
        "details": "Based on codebase analysis, the export functionality is primarily located in `src/components/ReportDisplay.tsx` and `src/utils/exportHelper.ts`.\n\n1.  **Modify UI Component:** In `src/components/ReportDisplay.tsx` (created in Task 16), remove the JSX for the 'Export CSV' and 'Export JSON' buttons.\n2.  **Remove Event Handlers:** Delete the corresponding `onClick` handler functions (e.g., `handleExportCSV`, `handleExportJSON`) from the component logic. These handlers contain the triggers for the Polar.sh payment modal (from Tasks 18 & 19), so removing them will also remove the primary payment trigger.\n3.  **Delete Utility File:** The file `src/utils/exportHelper.ts`, which contains the `exportAsCSV` and `exportAsJSON` functions, should be deleted entirely as it will no longer be used.\n4.  **Clean Up Imports:** Remove the import statement for `exportHelper.ts` from `src/components/ReportDisplay.tsx`.\n5.  **Review Payment Hook Usage:** Since the export buttons were the main trigger for the payment modal via the `usePayment` hook, review `ReportDisplay.tsx` to ensure no orphaned calls remain. This change will impact the implementation of the new payment solution in Task 21.",
        "testStrategy": "1.  **UI Verification:** Run the application and complete the workflow to the final report screen. Visually confirm that the 'Export CSV' and 'Export JSON' buttons are no longer present.\n2.  **Functional Verification:** Ensure that the removal of the export buttons has not negatively impacted the rendering or display of the calculated report data from Task 7.\n3.  **Code Review:** Perform a code review to confirm that the `src/utils/exportHelper.ts` file has been deleted. Verify that all related code (buttons, handler functions, and imports) has been removed from `src/components/ReportDisplay.tsx`.\n4.  **DevTools Check:** Check the browser's developer console for any errors related to missing functions or variables after the changes.",
        "status": "pending",
        "dependencies": [
          16,
          18,
          19
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Gated Access to ELSTER View via Payment Modal",
        "description": "Replace the previous direct export functionality by gating access to the ELSTER report view (Task 16) behind the existing Polar.sh payment modal (Task 18).",
        "details": "This task involves modifying the main report display to introduce a modal-based payment flow for accessing the ELSTER data.\n\n1.  **Modify `src/components/ReportDisplay.tsx`:** In the component from Task 16, add a new primary button or tab labeled 'Prepare for ELSTER'. This will be the sole entry point to the ELSTER view, replacing the buttons removed in Task 22.\n2.  **Implement State Management:** Introduce a new state variable, e.g., `isElsterAccessGranted`, initialized to `false`. This can be a simple React `useState` within the main application component that manages the end-to-end flow (as established in Task 6).\n3.  **Connect the Modal Trigger:** The `onClick` handler for the new 'Prepare for ELSTER' button should not navigate directly. Instead, it should call the function that displays the Polar.sh payment modal implemented in Task 18.\n4.  **Handle Modal Outcomes:** The Polar.sh modal component from Task 18 provides callbacks for success (payment) and skip. Both of these callbacks must be configured to update the state, setting `isElsterAccessGranted` to `true`.\n5.  **Conditional Rendering:** The ELSTER report component (from Task 16) should now be rendered conditionally. It should only be displayed when `isElsterAccessGranted` is `true`. Before that, the user should only see the main report summary and the 'Prepare for ELSTER' button.",
        "testStrategy": "1.  **Initial State:** After uploading a CSV and viewing the report, confirm that the ELSTER-mapped view is hidden and a 'Prepare for ELSTER' button is visible.\n2.  **Modal Trigger:** Click the 'Prepare for ELSTER' button. Verify that the Polar.sh payment modal (from Task 18) opens correctly.\n3.  **Skip Flow:** Click the 'Skip' or 'Continue for free' link within the modal. The modal should close, and the ELSTER-mapped report component (from Task 16) should become visible on the page.\n4.  **Payment Flow (Simulation):** Trigger the modal again. Simulate a successful payment via the Polar.sh SDK's test mode. Verify the modal closes and the ELSTER report becomes visible.\n5.  **State Persistence:** Once access has been granted (via skip or payment), verify that interacting with the 'Prepare for ELSTER' button again shows the report directly without re-triggering the modal for the current session.",
        "status": "pending",
        "dependencies": [
          16,
          18,
          22
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Redesign Landing Page Proof Section for Simplicity and Accessibility",
        "description": "Refactor the social proof/features section on the landing page to remove the card-based design and background, presenting the content in a simpler, more accessible list format.",
        "details": "Based on codebase analysis, the target component is likely a dedicated 'ProofSection' or similar within the main landing page view. The goal is to flatten the design for better readability.\n\n1. **Locate and Modify Component:** Identify the component responsible for rendering the proof/testimonial section on the landing page (e.g., `src/components/ProofSection.tsx` or a similar name).\n2. **Remove Card Styling:** In the component's associated CSS or styled-component definition, remove styles related to the card layout. This includes properties like `box-shadow`, `border`, `border-radius`, and any specific background colors applied to individual proof items.\n3. **Remove Section Background:** Eliminate any background image or complex background color from the main container of the proof section to create a cleaner look that matches the rest of the page body.\n4. **Refactor HTML Structure:** Change the markup to be more semantic and simpler. Replace the `div`-based card structure with a `<ul>` and `<li>` structure for the list of proofs. Each `<li>` can contain a heading and a paragraph for the proof's content.\n5. **Ensure Visual Separation:** Add a simple `border-top` and `border-bottom` to the section's main container, or use sufficient `margin-top` and `padding-bottom`, to visually distinguish it from the sections above and below it.\n6. **Review Content:** Simplify the text content within the proof section to be more direct and easier for end-users to understand quickly.",
        "testStrategy": "1. **Visual Verification:** Load the application and view the landing page. Confirm that the card design and section background have been removed and replaced with a simple list format.\n2. **Responsiveness Check:** Using browser developer tools, verify that the redesigned section is fully responsive and displays correctly on desktop, tablet, and mobile viewport sizes.\n3. **Accessibility Audit:** Run a Lighthouse accessibility audit on the landing page. Ensure the new section scores high, paying attention to color contrast, semantic HTML (e.g., correct use of lists), and font readability.\n4. **Separation Check:** Scroll the page to confirm there is clear visual separation between the redesigned proof section and the elements directly above and below it.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Left-Align Report View Rows",
        "description": "Update the styling of the EÜR report view to change the text alignment within rows from center to left. This improves readability and aligns with standard data table presentation.",
        "details": "Based on codebase analysis, the report data is rendered by the `src/components/ReportDisplay.tsx` component, as established in Task 7. The current implementation center-aligns the content within the report rows.\n\n1. **Locate Target Component:** Open the `src/components/ReportDisplay.tsx` file.\n2. **Identify Styling Rule:** Inspect the JSX and associated styles (could be an imported CSS/SCSS file, a styled-component block, or inline styles) that render the rows of the report.\n3. **Modify Alignment:** Search for the CSS property responsible for the center alignment, which is likely `text-align: center;` applied to a `<td>`, `<tr>`, or a container `<div>`. It could also be a flexbox property like `justify-content: center;`.\n4. **Apply Left Alignment:** Change the property to `text-align: left;` or `justify-content: flex-start;`. Ensure this change is applied consistently to all data rows in the report for a uniform appearance.",
        "testStrategy": "1. **UI Verification:** Run the application and navigate to the final report screen (as implemented in Task 7 and gated by Task 23). \n2. **Alignment Check:** Visually confirm that all text and numerical data within the report table/list are aligned to the left within their respective cells or containers.\n3. **Consistency Check:** Ensure that both the labels (e.g., 'Betriebseinnahmen') and the corresponding values (e.g., '€1234.56') are left-aligned.\n4. **Responsiveness Check:** Use browser developer tools to view the report on various screen sizes (mobile, tablet, desktop) and confirm the left-alignment is maintained and does not negatively impact the layout.",
        "status": "pending",
        "dependencies": [
          7
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-04T07:57:30.681Z",
      "updated": "2025-09-10T09:26:28.196Z",
      "description": "Tasks for master context"
    }
  }
}