{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize SPA Project with Vite, React, and Tailwind CSS",
        "description": "Set up the foundational client-side project structure for the EÜR Report Generator Single-Page Application (SPA).",
        "details": "Use Vite to scaffold a new React project. Integrate Tailwind CSS for styling as per the 'Logical Dependency Chain' foundation step. Establish the basic folder structure for components, logic (engines), and data models (`RawTransaction`, `NormalizedTransaction`, `EuerReport`).",
        "testStrategy": "Verify that the development server runs successfully and that a basic component with Tailwind CSS classes renders correctly in the browser.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Build Static UI Components for Upload and Report Display",
        "description": "Create the static, non-functional React components for the main application interface based on the specified user flow.",
        "details": "Implement a single-page layout as per the 'UI/UX Considerations'. Create a file input component with a clear call-to-action for CSV upload. Build a placeholder report display component with static labels matching the official EÜR form terminology.",
        "testStrategy": "Visual verification of components in the app or a tool like Storybook. Ensure the layout is clean, minimal, and follows the single-page design principle.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement CSV Parser and Data Normalization Logic",
        "description": "Develop the client-side logic to parse uploaded CSV files from Kontist and Holvi and transform them into a standardized internal format.",
        "details": "Use a client-side parsing library. Implement distinct adapters for Kontist and Holvi formats to handle potential future changes. The parser must identify the source bank and convert each row into the `NormalizedTransaction` data model.",
        "testStrategy": "Unit test the parsing and normalization logic with sample Kontist and Holvi CSV files. Assert that the output array of `NormalizedTransaction` objects is correct for both formats.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Develop SKR Categorization Engine",
        "description": "Create the core engine to automatically assign an official SKR accounting category to each transaction.",
        "details": "Build a function that takes a `NormalizedTransaction` and a ruleset. The engine will use keyword and pattern matching on the transaction description to map it to an SKR03/SKR04 category. The ruleset will be loaded from a JSON file as specified in the Appendix.",
        "testStrategy": "Write extensive unit tests. For a given transaction description and ruleset, assert that the correct SKR category is returned. Test edge cases and transactions that should remain uncategorized.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop EÜR Calculation Engine",
        "description": "Create the logic to calculate final EÜR financial figures from the set of categorized transactions.",
        "details": "Build a function that takes an array of categorized transactions. It will iterate through them, summing up income and expenses into buckets corresponding to the EÜR form fields. The output should match the `EuerReport` data model, calculating total income, expenses, and final profit/loss.",
        "testStrategy": "Unit test the calculation engine with various sets of categorized transactions. Verify that total income, total expenses, profit/loss, and category-specific totals are calculated correctly.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate Components for End-to-End Flow",
        "description": "Connect the UI, parser, and engines to create the complete, functional user workflow from file upload to final calculation and export.",
        "status": "done",
        "dependencies": [
          2,
          5
        ],
        "priority": "high",
        "details": "Wire the file upload component (Task 2) to trigger the CSV parser (Task 3). Pass the normalized transactions to the categorization engine (Task 4) and then to the calculation engine (Task 5). The final `EuerReport` object should be stored in the application's state, making it available for the report display (Task 7) and ELSTER export.",
        "testStrategy": "Manual end-to-end testing. Upload a test CSV and verify using browser dev tools that the application state is correctly updated with the final report data. Implement and test a loading indicator during processing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Connect File Upload UI to CSV Parser",
            "description": "Wire the file input component to trigger the CSV parsing logic upon file selection.",
            "status": "done",
            "dependencies": [],
            "details": "Implement an `onChange` handler for the file input from Task 2. Use the FileReader API to read the selected file's content and pass it to the CSV parser function from Task 3. Handle potential file reading errors.",
            "testStrategy": "Manually upload a file and use console logs or a debugger to confirm the parser function is called with the file content."
          },
          {
            "id": 2,
            "title": "Chain Parser Output to Categorization Engine",
            "description": "Pass the normalized transactions from the parser to the categorization engine.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Once the parser successfully returns an array of `NormalizedTransaction` objects, pass this array as input to the categorization engine (Task 4). This will enrich each transaction object with an EÜR category.",
            "testStrategy": "After parsing, inspect the data being passed to the categorization engine to ensure it's the correct array of normalized transactions."
          },
          {
            "id": 3,
            "title": "Feed Categorized Data into Calculation Engine",
            "description": "Use the output of the categorization engine to run the final EÜR calculations.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Take the array of categorized transactions and pass it to the EÜR calculation engine (Task 5). The engine will process this data and return the final `EuerReport` object.",
            "testStrategy": "Verify that the calculation engine receives the categorized transactions and that its output is a structured `EuerReport` object."
          },
          {
            "id": 4,
            "title": "Store Final Report in Application State",
            "description": "Update the global application state with the generated `EuerReport` and processing status.",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement state management logic (e.g., React Context). On successful calculation, update the state with the `EuerReport` object. Implement a loading state that is active from file selection until the calculation is complete. Handle and store any errors that occur during the process.",
            "testStrategy": "Use React DevTools to inspect the application state. Verify the loading state is set during processing and that the final state contains the correct `EuerReport` object or an error message."
          },
          {
            "id": 5,
            "title": "Implement ELSTER Data Export Function",
            "description": "Create a function to export the calculated EÜR report data into a downloadable format.",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "Add a button to the UI that becomes active after a report is generated. On click, this button should trigger a function that formats the `EuerReport` data into a simple, structured format (e.g., a key-value CSV or JSON file) and initiates a browser download.",
            "testStrategy": "Generate a report, click the export button, and verify that a file is downloaded. Inspect the file's contents to ensure it accurately reflects the data from the `EuerReport` object."
          }
        ]
      },
      {
        "id": 7,
        "title": "Populate Report Display with Calculated Data",
        "description": "Dynamically render the calculated EÜR report in the UI, making it ready for the user to transcribe to ELSTER.",
        "details": "Modify the report display component (Task 2) to consume the `EuerReport` data from the application state. Display the key calculated values with labels and line numbers that directly correspond to the official EÜR form, as specified in 'ELSTER-mapped Report Display'.",
        "testStrategy": "Visual and functional testing. Upload a test CSV and verify that the numbers displayed in the UI match the expected calculated totals. Cross-reference the UI labels with the official EÜR form.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Comprehensive Unit Testing for Core Logic",
        "description": "Fulfill the MVP requirement for unit tests covering the calculation and categorization logic.",
        "details": "Review and expand the unit tests for the categorization (Task 4) and calculation (Task 5) engines. Ensure high test coverage for these critical components to mitigate the risk of inaccurate financial reporting.",
        "testStrategy": "Run the full test suite and check coverage reports. Ensure tests cover common freelance income/expense types and edge cases.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Review & Document Categorization Engine Test Coverage",
            "description": "Analyze existing unit tests for the SKR Categorization Engine (Task 4), documenting current test cases, their coverage, and initial areas for expansion.",
            "dependencies": [],
            "details": "Utilize code coverage tools to assess current coverage. Document existing test cases for keyword/pattern matching, and uncategorized transactions as per Task 4's original test strategy.\n<info added on 2025-09-04T16:34:04.062Z>\nInitial review in 8.1 found a critical gap: no prior unit tests existed for the categorization engine. While a new suite (`src/test/categoryMappings.test.ts`) was created to validate static category definitions, the dynamic categorization logic remains untested.\n\nThis subtask will address this by adding tests for the core categorization algorithm, focusing on:\n- Keyword/pattern matching logic for assigning categories to transactions.\n- Fallback behavior for uncategorized transactions.\n- Correct category assignment using a variety of transaction descriptions and edge cases.\n- Multi-language keyword support.\n</info added on 2025-09-04T16:34:04.062Z>",
            "status": "done",
            "testStrategy": "N/A (This subtask focuses on review and documentation of existing tests)"
          },
          {
            "id": 2,
            "title": "Expand Categorization Engine Unit Tests",
            "description": "Develop new unit tests for the SKR Categorization Engine (Task 4) to cover common freelance income/expense types and specific edge cases, ensuring comprehensive coverage.",
            "dependencies": [
              "8.1"
            ],
            "details": "Focus on scenarios not adequately covered by existing tests, including ambiguous descriptions, multiple matching rules, and transactions that should remain uncategorized. Ensure tests align with the parent task's requirement for covering common freelance income/expense types and edge cases.",
            "status": "done",
            "testStrategy": "Write new unit tests using various transaction descriptions and rulesets, asserting correct SKR category assignment or non-assignment for identified gaps."
          },
          {
            "id": 3,
            "title": "Review & Document Calculation Engine Test Coverage",
            "description": "Analyze existing unit tests for the EÜR Calculation Engine (Task 5), documenting current test cases, their coverage, and initial areas for expansion.",
            "dependencies": [],
            "details": "Utilize code coverage tools to assess current coverage. Document existing test cases for various income/expense types, profit/loss calculation, and category-specific totals as per Task 5's original test strategy.",
            "status": "done",
            "testStrategy": "N/A (This subtask focuses on review and documentation of existing tests)"
          },
          {
            "id": 4,
            "title": "Expand Calculation Engine Unit Tests",
            "description": "Develop new unit tests for the EÜR Calculation Engine (Task 5) using diverse sets of categorized transactions to verify accurate financial figure calculation across various scenarios.",
            "dependencies": [
              "8.3"
            ],
            "details": "Create test data targeting the calculation of total income, total expenses, profit/loss, and category-specific totals under conditions like zero values, mixed types, and large transaction volumes. Ensure tests align with the parent task's requirement for covering common freelance income/expense types and edge cases.",
            "status": "done",
            "testStrategy": "Write new unit tests with varied categorized transaction inputs, asserting correct output for `EuerReport` fields."
          },
          {
            "id": 5,
            "title": "Achieve & Verify High Test Coverage for Core Logic",
            "description": "Run the full unit test suite for both Categorization (Task 4) and Calculation (Task 5) engines, analyze coverage reports, and ensure high test coverage (e.g., >90% line coverage) for their core logic.",
            "dependencies": [
              "8.2",
              "8.4"
            ],
            "details": "Use the configured test runner and coverage reporting tools. Address any remaining low-coverage areas by adding targeted tests until the high test coverage requirement is met for both critical components.",
            "status": "done",
            "testStrategy": "Run the full test suite and check coverage reports. Ensure the target coverage percentage is met for both the categorization and calculation engines."
          }
        ]
      },
      {
        "id": 9,
        "title": "Refine UI/UX and Handle Error States",
        "description": "Polish the user interface and implement robust handling for potential user errors and edge cases.",
        "details": "Implement user-friendly error messages for invalid file types (non-CSV), corrupted files, or parsing failures. Add a small info section explaining the client-side privacy model. Ensure the entire experience is intuitive for the non-accountant user persona.",
        "testStrategy": "Manual testing of error paths: upload a .txt file, a corrupted CSV, or a CSV from an unsupported bank. Ensure clear, helpful feedback is provided to the user.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Configure Static Site Deployment",
        "description": "Set up automated deployment to a static web hosting provider to make the MVP publicly accessible.",
        "details": "Configure a CI/CD pipeline (e.g., using GitHub Actions) to automatically build and deploy the application to a provider like Vercel, Netlify, or GitHub Pages upon pushes to the main branch.",
        "testStrategy": "Trigger a deployment by pushing a commit. Verify that the deployed site is live and fully functional by performing a complete user flow on the production URL.",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Setup SPA Project and Basic UI Shell",
        "description": "Initialize a client-side Single-Page Application (SPA) and create the main layout with placeholders for the file upload and report display areas.",
        "details": "Use Vite and Tailwind CSS as specified in the PRD. Create a single-page layout with a clear call-to-action for file upload and an empty placeholder section for the final report display. This task corresponds to the 'Foundation' and 'Static UI' steps in the logical dependency chain.",
        "testStrategy": "Run the development server and verify the basic layout renders correctly in the browser without errors. The file input and a placeholder for the report should be visible.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Define Core Data Models and Static Data",
        "description": "Create the TypeScript/JavaScript definitions for `RawTransaction`, `NormalizedTransaction`, and `EuerReport`, and set up the static SKR mapping files.",
        "details": "Define the data structures as specified in the 'Data Models' section of the PRD. Create `src/data/skr03.json` and `src/data/skr04.json` with initial mapping rules for common freelance income/expense categories.",
        "testStrategy": "Code review to ensure models match the PRD specifications. JSON files should be linted and validated to ensure they are parseable.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement CSV Parsing for Kontist & Holvi",
        "description": "Develop the logic to parse uploaded `.csv` files from Kontist and Holvi, transforming the data into the standardized `NormalizedTransaction` format.",
        "details": "Use a client-side CSV parsing library (e.g., PapaParse). Implement an adapter layer that detects the source bank (Kontist/Holvi) based on header columns and maps its specific format to the `NormalizedTransaction` model. Handle potential parsing errors gracefully.",
        "testStrategy": "Unit test the parsing logic with sample CSV files for both banks. Verify that the output is an array of valid `NormalizedTransaction` objects and that edge cases (empty files, malformed rows) are handled.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Build the SKR Categorization Engine",
        "description": "Create the core engine that assigns an SKR category to each `NormalizedTransaction` based on predefined rules.",
        "details": "The engine will iterate through an array of `NormalizedTransaction`s. It will use a ruleset based on keywords and patterns in the transaction description to match against the SKR mapping data loaded from the JSON files. Uncategorized items should be handled gracefully as per the PRD's risk mitigation.",
        "testStrategy": "Write unit tests that pass in various `NormalizedTransaction` objects and assert that the correct SKR category is assigned. Test with common freelance expenses like 'Software', 'Travel', and 'Office Supplies'.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Build the EÜR Calculation Engine",
        "description": "Create the logic to process the list of categorized transactions and compute the final EÜR report totals.",
        "details": "The engine will take an array of categorized `NormalizedTransaction`s as input. It will sum up all income and expense lines, grouping them by their assigned SKR category, to produce the final `EuerReport` object containing total income, total expenses, and profit/loss.",
        "testStrategy": "Unit test the calculation engine with a predefined set of categorized transactions. Verify that total income, total expenses, and profit/loss are calculated correctly. Test with zero transactions and only income/expense transactions.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Create the ELSTER-mapped Report Display",
        "description": "Build the UI component that takes the final `EuerReport` object and displays the results in a clean, read-only format matching the ELSTER form.",
        "details": "The component will render the key calculated values (e.g., 'Betriebseinnahmen', 'Wareneinkauf', 'Gewinn/Verlust') with labels and line numbers corresponding to the official EÜR form. This component will replace the placeholder from task 11.",
        "testStrategy": "Manually test by feeding a mock `EuerReport` object to the component and verifying the display is accurate, clean, and user-friendly. Check that all relevant fields from the report object are displayed.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Integrate All MVP Components for End-to-End Flow",
        "description": "Connect the file upload, parsing, categorization, calculation, and display components to create the complete, functional user workflow for the MVP.",
        "details": "Wire the file input to trigger the CSV parser. Pass the normalized data to the categorization and calculation engines. Feed the final `EuerReport` to the display component. Implement a loading indicator that is shown during processing.",
        "testStrategy": "Perform end-to-end manual testing: upload a Kontist CSV, verify the loading state, and check that the final report is displayed correctly. Repeat the process for a Holvi CSV.",
        "priority": "high",
        "dependencies": [
          13,
          15,
          16
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Project Repository and Basic Structure",
            "description": "Set up the version control repository, define initial project directories (e.g., `src`, `tests`, `docs`), and configure basic build tools and dependency management.",
            "dependencies": [],
            "details": "Use Git for version control. Create a `.gitignore` file. Configure `package.json` (for Node.js), `pyproject.toml` (for Python), or `pom.xml` (for Java) for dependency management. Establish a clear folder structure for frontend, backend, and shared components.",
            "status": "done",
            "testStrategy": "Verify repository creation and that basic build/install commands (e.g., `npm install`, `pip install -e .`) run without errors. Confirm `.gitignore` is effective."
          },
          {
            "id": 2,
            "title": "Design Database Schema and Configure ORM",
            "description": "Define the necessary database tables, relationships, and data types for the application's core entities. Integrate and configure an Object-Relational Mapper (ORM) to interact with the database.",
            "dependencies": [],
            "details": "Choose a suitable database (e.g., PostgreSQL, MySQL). Design tables for users, items, orders, etc., including primary keys, foreign keys, and appropriate data types. Use an ORM like SQLAlchemy, Sequelize, or Hibernate. Define ORM models corresponding to the database schema.",
            "status": "done",
            "testStrategy": "Write and apply initial database migration scripts to a local development database. Verify that ORM models can connect to the database and perform basic CRUD (Create, Read, Update, Delete) operations on dummy data."
          },
          {
            "id": 3,
            "title": "Develop Core Backend API Endpoints",
            "description": "Implement the essential RESTful API endpoints for data manipulation (CRUD operations) based on the defined database schema and ORM models.",
            "dependencies": [],
            "details": "Use a chosen backend framework (e.g., Flask, Express, Spring Boot). Implement endpoints for creating, reading, updating, and deleting primary resources (e.g., `/api/items`, `/api/users`). Ensure proper request validation, error handling, and serialization/deserialization of data.",
            "status": "done",
            "testStrategy": "Use an API client (e.g., Postman, Insomnia) or write unit/integration tests to verify each endpoint's functionality, HTTP status codes, and response payloads for various scenarios (success, invalid input, resource not found)."
          },
          {
            "id": 4,
            "title": "Implement Key Frontend UI Components",
            "description": "Create the main user interface components required for displaying and interacting with the data exposed by the backend API.",
            "dependencies": [],
            "details": "Choose a frontend framework (e.g., React, Angular, Vue.js). Develop reusable components such as data display tables/lists, forms for data input, navigation elements, and basic layout components. Focus on static rendering and component structure initially.",
            "status": "done",
            "testStrategy": "Visually inspect components in a browser to ensure correct rendering and responsiveness. Use component-level testing frameworks (e.g., Jest, React Testing Library) to verify components render correctly with different props and respond to basic simulated user interactions."
          },
          {
            "id": 5,
            "title": "Integrate Frontend with Backend API and Implement Data Flow",
            "description": "Connect the frontend UI components to the backend API endpoints to fetch, display, and submit data. Implement application-wide state management for data flow.",
            "dependencies": [],
            "details": "Use `fetch` API or a library like Axios for HTTP requests from the frontend. Implement data fetching on component mount, form submission handling, and real-time updates. Manage application state using a suitable pattern (e.g., Context API, Redux, Vuex, Zustand) to ensure consistent data across components.",
            "status": "done",
            "testStrategy": "Perform end-to-end testing by interacting with the UI and verifying that data is correctly fetched from and submitted to the backend. Use browser developer tools to monitor network requests and responses. Test various user flows involving data interaction."
          },
          {
            "id": 6,
            "title": "Implement User Authentication and Authorization",
            "description": "Add user authentication (e.g., login, registration, logout) and authorization (e.g., role-based access control) to secure the application's resources and features.",
            "dependencies": [],
            "details": "Implement user registration and login endpoints on the backend, using secure password hashing (e.g., bcrypt) and token-based (e.g., JWT) or session-based authentication. Protect API routes based on user roles/permissions. Implement login/logout UI flows, protected routes, and display user-specific content on the frontend.",
            "status": "done",
            "testStrategy": "Test login/logout functionality with valid and invalid credentials. Verify that protected API routes are inaccessible without proper authentication/authorization. Test different user roles to ensure correct access levels to features and data. Check for secure storage of tokens/sessions."
          }
        ]
      },
      {
        "id": 18,
        "title": "Integrate Polar.sh Payment Modal",
        "description": "Implement the payment modal that appears when a user clicks on an ELSTER export button or information icon.",
        "details": "Use the Polar.sh SDK to trigger and display the checkout modal. The modal should offer the option to make a voluntary payment or to skip and continue for free, as described in the user flow.",
        "testStrategy": "Manually trigger the modal from the UI. Verify the Polar.sh checkout loads correctly within the modal. Test the 'skip' functionality to ensure the user can proceed without paying.",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Product Database Schema",
            "description": "Define the database schema for products, categories, and related entities. Set up the database and initial tables.",
            "dependencies": [],
            "details": "Use PostgreSQL. Tables: `products` (id, name, description, price, stock, category_id), `categories` (id, name). Ensure proper indexing and foreign key constraints. Create migration scripts.\n<info added on 2025-09-10T07:33:10.471Z>\nWith the `PaymentModal.tsx` component now successfully integrating the Polar.sh SDK on the client side, this backend subtask is unblocked. The goal is to create an API endpoint that will serve the product/donation options from the database to the frontend.\n\n**Implementation Plan:**\n\n1.  **Create API Endpoint:** Implement a new `GET /api/products` endpoint. Following the existing backend structure, this will likely involve adding a new route in the `server/routes/` directory and a corresponding controller function.\n2.  **Database Query:** The controller for this endpoint should query the PostgreSQL `products` table (defined in subtask 18.1) to fetch all available products.\n3.  **Data Structure:** The endpoint should return a JSON array of product objects. Each object should include the necessary fields for the frontend, such as `id`, `name`, `description`, and `price`.\n4.  **Frontend Integration (Next Step):** Once this endpoint is live, the `PaymentModal.tsx` component will be refactored to fetch data from `/api/products` instead of using client-side dynamic values. This will decouple the product offerings from the frontend code.\n</info added on 2025-09-10T07:33:10.471Z>",
            "status": "done",
            "testStrategy": "Verify table creation, column types, constraints, and ability to insert/retrieve basic data using SQL queries directly against the database."
          },
          {
            "id": 2,
            "title": "Implement Product Listing API Endpoint",
            "description": "Create an API endpoint to retrieve a list of all products, with optional filtering and pagination.",
            "dependencies": [],
            "details": "Endpoint: `/api/products`. Support query parameters for `category_id`, `min_price`, `max_price`, `page`, `limit`. Use a RESTful approach, returning JSON.",
            "status": "done",
            "testStrategy": "Unit tests for data retrieval logic. Integration tests for the API endpoint using HTTP requests, checking various filter combinations, pagination, and empty results."
          },
          {
            "id": 3,
            "title": "Implement Single Product Details API Endpoint",
            "description": "Create an API endpoint to retrieve details for a specific product by its ID.",
            "dependencies": [],
            "details": "Endpoint: `/api/products/{id}`. Handle cases where the product ID does not exist (return 404 Not Found). Include category name in the response.",
            "status": "done",
            "testStrategy": "Unit tests for fetching by ID. Integration tests for the API endpoint, checking valid IDs, non-existent IDs, and ensuring correct data structure and status codes."
          },
          {
            "id": 4,
            "title": "Implement Product Creation API Endpoint",
            "description": "Create an API endpoint to allow authenticated users to add new products to the catalog.",
            "dependencies": [],
            "details": "Endpoint: `/api/products` (POST request). Request body should include `name`, `description`, `price`, `stock`, `category_id`. Implement input validation (e.g., price > 0, stock >= 0, category_id exists). Return 201 Created with the new product's details.",
            "status": "done",
            "testStrategy": "Unit tests for validation logic. Integration tests for the API endpoint, sending valid and invalid product data, verifying successful creation, and checking error responses for invalid inputs."
          }
        ]
      },
      {
        "id": 19,
        "title": "Manage Payment Flow and Add Secondary CTA",
        "description": "Implement logic to handle payment success/failure and add a subtle call-to-action for later contributions in the export view.",
        "details": "Use callbacks or promises from the Polar.sh SDK to detect payment completion. Display a simple confirmation message on success. Add a non-intrusive 'Support this tool' button in the final report view that re-opens the payment modal.",
        "testStrategy": "Use Polar.sh test mode to simulate a successful payment and verify the confirmation UI appears. Verify the secondary CTA is present and correctly triggers the payment modal again.",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Database Schema",
            "description": "Define the database schema for core entities (e.g., users, products, orders) and set up the initial database environment.",
            "dependencies": [],
            "details": "Create SQL DDL scripts for tables like `users` (id, name, email, password_hash), `products` (id, name, description, price, stock), and `orders` (id, user_id, order_date, total_amount). Use PostgreSQL for the database. Ensure proper indexing for foreign keys and frequently queried columns.",
            "status": "done",
            "testStrategy": "Verify table creation and schema integrity using a database client. Insert sample data to confirm data types and constraints are enforced correctly."
          },
          {
            "id": 2,
            "title": "Develop User Authentication and Authorization Module",
            "description": "Implement user registration, login, and token-based authentication (e.g., JWT). Include basic role-based authorization.",
            "dependencies": [],
            "details": "Create API endpoints for `/register` (POST), `/login` (POST), and `/profile` (GET, protected). Use bcrypt for password hashing. Implement JWT generation on login and validation for protected routes. Define roles (e.g., 'user', 'admin') and enforce access control on specific endpoints.",
            "status": "done",
            "testStrategy": "Test user registration with valid/invalid data. Verify successful login and JWT generation. Test access to protected routes with valid/invalid/missing tokens. Confirm authorization rules are applied correctly for different user roles."
          },
          {
            "id": 3,
            "title": "Implement Product Catalog Management API",
            "description": "Develop CRUD (Create, Read, Update, Delete) API endpoints for managing product information.",
            "dependencies": [],
            "details": "Create RESTful endpoints: `/products` (GET all, POST new), `/products/{id}` (GET by ID, PUT/PATCH update, DELETE). Implement input validation for product data (name, price, stock). Ensure only authenticated and authorized users (e.g., 'admin' role) can create, update, or delete products.",
            "status": "done",
            "testStrategy": "Use Postman or cURL to test all CRUD operations. Verify correct HTTP status codes (200, 201, 204, 400, 401, 403, 404). Test edge cases like invalid product IDs, missing required fields, and unauthorized access attempts."
          },
          {
            "id": 4,
            "title": "Set Up API Documentation and Deployment Configuration",
            "description": "Generate comprehensive API documentation and configure basic deployment settings for the application.",
            "dependencies": [],
            "details": "Use OpenAPI/Swagger to document all implemented API endpoints, including request/response schemas, authentication requirements, and error codes. Create a `Dockerfile` for containerizing the application and a basic `docker-compose.yml` for local development and testing environment setup.",
            "status": "done",
            "testStrategy": "Verify that the generated API documentation is accurate, complete, and accessible. Build the Docker image and run the application in a container to ensure it starts correctly and all endpoints are reachable from within the containerized environment."
          }
        ]
      },
      {
        "id": 20,
        "title": "Deploy MVP to Static Hosting",
        "description": "Configure and deploy the completed client-side application to a static web host like Vercel, Netlify, or GitHub Pages.",
        "details": "Set up a build pipeline for the SPA. Configure the chosen hosting provider to serve the static files from the `dist` directory. Ensure environment variables for Polar.sh (if any) are set up correctly.",
        "testStrategy": "Access the live URL and perform a final smoke test of the entire user flow, including file upload and the payment modal, to ensure it works correctly in a production environment.",
        "priority": "low",
        "dependencies": [
          17,
          19
        ],
        "status": "in-progress",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-04T07:57:30.681Z",
      "updated": "2025-09-10T08:29:35.190Z",
      "description": "Tasks for master context"
    }
  }
}